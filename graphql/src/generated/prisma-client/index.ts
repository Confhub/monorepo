// Code generated by Prisma (prisma@1.22.2). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  conference: (where?: ConferenceWhereInput) => Promise<boolean>;
  coordinates: (where?: CoordinatesWhereInput) => Promise<boolean>;
  image: (where?: ImageWhereInput) => Promise<boolean>;
  location: (where?: LocationWhereInput) => Promise<boolean>;
  price: (where?: PriceWhereInput) => Promise<boolean>;
  social: (where?: SocialWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  conference: (where: ConferenceWhereUniqueInput) => ConferencePromise;
  conferences: (
    args?: {
      where?: ConferenceWhereInput;
      orderBy?: ConferenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Conference>;
  conferencesConnection: (
    args?: {
      where?: ConferenceWhereInput;
      orderBy?: ConferenceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ConferenceConnectionPromise;
  coordinates: (where: CoordinatesWhereUniqueInput) => CoordinatesPromise;
  coordinateses: (
    args?: {
      where?: CoordinatesWhereInput;
      orderBy?: CoordinatesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Coordinates>;
  coordinatesesConnection: (
    args?: {
      where?: CoordinatesWhereInput;
      orderBy?: CoordinatesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CoordinatesConnectionPromise;
  image: (where: ImageWhereUniqueInput) => ImagePromise;
  images: (
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Image>;
  imagesConnection: (
    args?: {
      where?: ImageWhereInput;
      orderBy?: ImageOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ImageConnectionPromise;
  location: (where: LocationWhereUniqueInput) => LocationPromise;
  locations: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Location>;
  locationsConnection: (
    args?: {
      where?: LocationWhereInput;
      orderBy?: LocationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LocationConnectionPromise;
  price: (where: PriceWhereUniqueInput) => PricePromise;
  prices: (
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Price>;
  pricesConnection: (
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PriceConnectionPromise;
  social: (where: SocialWhereUniqueInput) => SocialPromise;
  socials: (
    args?: {
      where?: SocialWhereInput;
      orderBy?: SocialOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Social>;
  socialsConnection: (
    args?: {
      where?: SocialWhereInput;
      orderBy?: SocialOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SocialConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagPromise;
  tags: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Tag>;
  tagsConnection: (
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createConference: (data: ConferenceCreateInput) => ConferencePromise;
  updateConference: (
    args: { data: ConferenceUpdateInput; where: ConferenceWhereUniqueInput }
  ) => ConferencePromise;
  updateManyConferences: (
    args: {
      data: ConferenceUpdateManyMutationInput;
      where?: ConferenceWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertConference: (
    args: {
      where: ConferenceWhereUniqueInput;
      create: ConferenceCreateInput;
      update: ConferenceUpdateInput;
    }
  ) => ConferencePromise;
  deleteConference: (where: ConferenceWhereUniqueInput) => ConferencePromise;
  deleteManyConferences: (where?: ConferenceWhereInput) => BatchPayloadPromise;
  createCoordinates: (data: CoordinatesCreateInput) => CoordinatesPromise;
  updateCoordinates: (
    args: { data: CoordinatesUpdateInput; where: CoordinatesWhereUniqueInput }
  ) => CoordinatesPromise;
  updateManyCoordinateses: (
    args: {
      data: CoordinatesUpdateManyMutationInput;
      where?: CoordinatesWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertCoordinates: (
    args: {
      where: CoordinatesWhereUniqueInput;
      create: CoordinatesCreateInput;
      update: CoordinatesUpdateInput;
    }
  ) => CoordinatesPromise;
  deleteCoordinates: (where: CoordinatesWhereUniqueInput) => CoordinatesPromise;
  deleteManyCoordinateses: (
    where?: CoordinatesWhereInput
  ) => BatchPayloadPromise;
  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (
    args: { data: ImageUpdateInput; where: ImageWhereUniqueInput }
  ) => ImagePromise;
  updateManyImages: (
    args: { data: ImageUpdateManyMutationInput; where?: ImageWhereInput }
  ) => BatchPayloadPromise;
  upsertImage: (
    args: {
      where: ImageWhereUniqueInput;
      create: ImageCreateInput;
      update: ImageUpdateInput;
    }
  ) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createLocation: (data: LocationCreateInput) => LocationPromise;
  updateLocation: (
    args: { data: LocationUpdateInput; where: LocationWhereUniqueInput }
  ) => LocationPromise;
  updateManyLocations: (
    args: { data: LocationUpdateManyMutationInput; where?: LocationWhereInput }
  ) => BatchPayloadPromise;
  upsertLocation: (
    args: {
      where: LocationWhereUniqueInput;
      create: LocationCreateInput;
      update: LocationUpdateInput;
    }
  ) => LocationPromise;
  deleteLocation: (where: LocationWhereUniqueInput) => LocationPromise;
  deleteManyLocations: (where?: LocationWhereInput) => BatchPayloadPromise;
  createPrice: (data: PriceCreateInput) => PricePromise;
  updatePrice: (
    args: { data: PriceUpdateInput; where: PriceWhereUniqueInput }
  ) => PricePromise;
  updateManyPrices: (
    args: { data: PriceUpdateManyMutationInput; where?: PriceWhereInput }
  ) => BatchPayloadPromise;
  upsertPrice: (
    args: {
      where: PriceWhereUniqueInput;
      create: PriceCreateInput;
      update: PriceUpdateInput;
    }
  ) => PricePromise;
  deletePrice: (where: PriceWhereUniqueInput) => PricePromise;
  deleteManyPrices: (where?: PriceWhereInput) => BatchPayloadPromise;
  createSocial: (data: SocialCreateInput) => SocialPromise;
  updateSocial: (
    args: { data: SocialUpdateInput; where: SocialWhereUniqueInput }
  ) => SocialPromise;
  updateManySocials: (
    args: { data: SocialUpdateManyMutationInput; where?: SocialWhereInput }
  ) => BatchPayloadPromise;
  upsertSocial: (
    args: {
      where: SocialWhereUniqueInput;
      create: SocialCreateInput;
      update: SocialUpdateInput;
    }
  ) => SocialPromise;
  deleteSocial: (where: SocialWhereUniqueInput) => SocialPromise;
  deleteManySocials: (where?: SocialWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (
    args: { data: TagUpdateInput; where: TagWhereUniqueInput }
  ) => TagPromise;
  updateManyTags: (
    args: { data: TagUpdateManyMutationInput; where?: TagWhereInput }
  ) => BatchPayloadPromise;
  upsertTag: (
    args: {
      where: TagWhereUniqueInput;
      create: TagCreateInput;
      update: TagUpdateInput;
    }
  ) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  conference: (
    where?: ConferenceSubscriptionWhereInput
  ) => ConferenceSubscriptionPayloadSubscription;
  coordinates: (
    where?: CoordinatesSubscriptionWhereInput
  ) => CoordinatesSubscriptionPayloadSubscription;
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  location: (
    where?: LocationSubscriptionWhereInput
  ) => LocationSubscriptionPayloadSubscription;
  price: (
    where?: PriceSubscriptionWhereInput
  ) => PriceSubscriptionPayloadSubscription;
  social: (
    where?: SocialSubscriptionWhereInput
  ) => SocialSubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type TagOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "slug_ASC"
  | "slug_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PUBLISH_STATUS = "DRAFT" | "PUBLISHED";

export type CURRENCY = "USD" | "EUR";

export type PriceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "expirationDate_ASC"
  | "expirationDate_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ConferenceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "url_ASC"
  | "url_DESC"
  | "startDate_ASC"
  | "startDate_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "publishStatus_ASC"
  | "publishStatus_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CoordinatesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "latitude_ASC"
  | "latitude_DESC"
  | "longitude_ASC"
  | "longitude_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "src_ASC"
  | "src_DESC"
  | "alt_ASC"
  | "alt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type LocationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "venueName_ASC"
  | "venueName_DESC"
  | "continent_ASC"
  | "continent_DESC"
  | "country_ASC"
  | "country_DESC"
  | "city_ASC"
  | "city_DESC"
  | "address_ASC"
  | "address_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SocialOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "facebook_ASC"
  | "facebook_DESC"
  | "twitter_ASC"
  | "twitter_DESC"
  | "instagram_ASC"
  | "instagram_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type USER_ROLE = "ATTENDEE" | "SPEAKER" | "MODERATOR";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ConferenceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TagWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  AND?: TagWhereInput[] | TagWhereInput;
  OR?: TagWhereInput[] | TagWhereInput;
  NOT?: TagWhereInput[] | TagWhereInput;
}

export interface PriceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  currency?: CURRENCY;
  currency_not?: CURRENCY;
  currency_in?: CURRENCY[] | CURRENCY;
  currency_not_in?: CURRENCY[] | CURRENCY;
  expirationDate?: DateTimeInput;
  expirationDate_not?: DateTimeInput;
  expirationDate_in?: DateTimeInput[] | DateTimeInput;
  expirationDate_not_in?: DateTimeInput[] | DateTimeInput;
  expirationDate_lt?: DateTimeInput;
  expirationDate_lte?: DateTimeInput;
  expirationDate_gt?: DateTimeInput;
  expirationDate_gte?: DateTimeInput;
  AND?: PriceWhereInput[] | PriceWhereInput;
  OR?: PriceWhereInput[] | PriceWhereInput;
  NOT?: PriceWhereInput[] | PriceWhereInput;
}

export interface ConferenceWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  tags_every?: TagWhereInput;
  tags_some?: TagWhereInput;
  tags_none?: TagWhereInput;
  url?: String;
  url_not?: String;
  url_in?: String[] | String;
  url_not_in?: String[] | String;
  url_lt?: String;
  url_lte?: String;
  url_gt?: String;
  url_gte?: String;
  url_contains?: String;
  url_not_contains?: String;
  url_starts_with?: String;
  url_not_starts_with?: String;
  url_ends_with?: String;
  url_not_ends_with?: String;
  image?: ImageWhereInput;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  location?: LocationWhereInput;
  social?: SocialWhereInput;
  publishStatus?: PUBLISH_STATUS;
  publishStatus_not?: PUBLISH_STATUS;
  publishStatus_in?: PUBLISH_STATUS[] | PUBLISH_STATUS;
  publishStatus_not_in?: PUBLISH_STATUS[] | PUBLISH_STATUS;
  prices_every?: PriceWhereInput;
  prices_some?: PriceWhereInput;
  prices_none?: PriceWhereInput;
  AND?: ConferenceWhereInput[] | ConferenceWhereInput;
  OR?: ConferenceWhereInput[] | ConferenceWhereInput;
  NOT?: ConferenceWhereInput[] | ConferenceWhereInput;
}

export interface ImageWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  src?: String;
  src_not?: String;
  src_in?: String[] | String;
  src_not_in?: String[] | String;
  src_lt?: String;
  src_lte?: String;
  src_gt?: String;
  src_gte?: String;
  src_contains?: String;
  src_not_contains?: String;
  src_starts_with?: String;
  src_not_starts_with?: String;
  src_ends_with?: String;
  src_not_ends_with?: String;
  alt?: String;
  alt_not?: String;
  alt_in?: String[] | String;
  alt_not_in?: String[] | String;
  alt_lt?: String;
  alt_lte?: String;
  alt_gt?: String;
  alt_gte?: String;
  alt_contains?: String;
  alt_not_contains?: String;
  alt_starts_with?: String;
  alt_not_starts_with?: String;
  alt_ends_with?: String;
  alt_not_ends_with?: String;
  AND?: ImageWhereInput[] | ImageWhereInput;
  OR?: ImageWhereInput[] | ImageWhereInput;
  NOT?: ImageWhereInput[] | ImageWhereInput;
}

export interface LocationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  venueName?: String;
  venueName_not?: String;
  venueName_in?: String[] | String;
  venueName_not_in?: String[] | String;
  venueName_lt?: String;
  venueName_lte?: String;
  venueName_gt?: String;
  venueName_gte?: String;
  venueName_contains?: String;
  venueName_not_contains?: String;
  venueName_starts_with?: String;
  venueName_not_starts_with?: String;
  venueName_ends_with?: String;
  venueName_not_ends_with?: String;
  continent?: String;
  continent_not?: String;
  continent_in?: String[] | String;
  continent_not_in?: String[] | String;
  continent_lt?: String;
  continent_lte?: String;
  continent_gt?: String;
  continent_gte?: String;
  continent_contains?: String;
  continent_not_contains?: String;
  continent_starts_with?: String;
  continent_not_starts_with?: String;
  continent_ends_with?: String;
  continent_not_ends_with?: String;
  country?: String;
  country_not?: String;
  country_in?: String[] | String;
  country_not_in?: String[] | String;
  country_lt?: String;
  country_lte?: String;
  country_gt?: String;
  country_gte?: String;
  country_contains?: String;
  country_not_contains?: String;
  country_starts_with?: String;
  country_not_starts_with?: String;
  country_ends_with?: String;
  country_not_ends_with?: String;
  city?: String;
  city_not?: String;
  city_in?: String[] | String;
  city_not_in?: String[] | String;
  city_lt?: String;
  city_lte?: String;
  city_gt?: String;
  city_gte?: String;
  city_contains?: String;
  city_not_contains?: String;
  city_starts_with?: String;
  city_not_starts_with?: String;
  city_ends_with?: String;
  city_not_ends_with?: String;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  coordinates?: CoordinatesWhereInput;
  AND?: LocationWhereInput[] | LocationWhereInput;
  OR?: LocationWhereInput[] | LocationWhereInput;
  NOT?: LocationWhereInput[] | LocationWhereInput;
}

export interface CoordinatesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  latitude?: Float;
  latitude_not?: Float;
  latitude_in?: Float[] | Float;
  latitude_not_in?: Float[] | Float;
  latitude_lt?: Float;
  latitude_lte?: Float;
  latitude_gt?: Float;
  latitude_gte?: Float;
  longitude?: Float;
  longitude_not?: Float;
  longitude_in?: Float[] | Float;
  longitude_not_in?: Float[] | Float;
  longitude_lt?: Float;
  longitude_lte?: Float;
  longitude_gt?: Float;
  longitude_gte?: Float;
  AND?: CoordinatesWhereInput[] | CoordinatesWhereInput;
  OR?: CoordinatesWhereInput[] | CoordinatesWhereInput;
  NOT?: CoordinatesWhereInput[] | CoordinatesWhereInput;
}

export interface SocialWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  facebook?: String;
  facebook_not?: String;
  facebook_in?: String[] | String;
  facebook_not_in?: String[] | String;
  facebook_lt?: String;
  facebook_lte?: String;
  facebook_gt?: String;
  facebook_gte?: String;
  facebook_contains?: String;
  facebook_not_contains?: String;
  facebook_starts_with?: String;
  facebook_not_starts_with?: String;
  facebook_ends_with?: String;
  facebook_not_ends_with?: String;
  twitter?: String;
  twitter_not?: String;
  twitter_in?: String[] | String;
  twitter_not_in?: String[] | String;
  twitter_lt?: String;
  twitter_lte?: String;
  twitter_gt?: String;
  twitter_gte?: String;
  twitter_contains?: String;
  twitter_not_contains?: String;
  twitter_starts_with?: String;
  twitter_not_starts_with?: String;
  twitter_ends_with?: String;
  twitter_not_ends_with?: String;
  instagram?: String;
  instagram_not?: String;
  instagram_in?: String[] | String;
  instagram_not_in?: String[] | String;
  instagram_lt?: String;
  instagram_lte?: String;
  instagram_gt?: String;
  instagram_gte?: String;
  instagram_contains?: String;
  instagram_not_contains?: String;
  instagram_starts_with?: String;
  instagram_not_starts_with?: String;
  instagram_ends_with?: String;
  instagram_not_ends_with?: String;
  AND?: SocialWhereInput[] | SocialWhereInput;
  OR?: SocialWhereInput[] | SocialWhereInput;
  NOT?: SocialWhereInput[] | SocialWhereInput;
}

export type CoordinatesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ImageWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type LocationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PriceWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type SocialWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TagWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  slug?: String;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  role?: USER_ROLE;
  role_not?: USER_ROLE;
  role_in?: USER_ROLE[] | USER_ROLE;
  role_not_in?: USER_ROLE[] | USER_ROLE;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface ConferenceCreateInput {
  name: String;
  description?: String;
  tags?: TagCreateManyInput;
  url: String;
  image?: ImageCreateOneInput;
  startDate: DateTimeInput;
  endDate: DateTimeInput;
  location: LocationCreateOneInput;
  social?: SocialCreateOneInput;
  publishStatus?: PUBLISH_STATUS;
  prices?: PriceCreateManyInput;
}

export interface TagCreateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
}

export interface TagCreateInput {
  name: String;
  slug: String;
}

export interface ImageCreateOneInput {
  create?: ImageCreateInput;
  connect?: ImageWhereUniqueInput;
}

export interface ImageCreateInput {
  src: String;
  alt?: String;
}

export interface LocationCreateOneInput {
  create?: LocationCreateInput;
  connect?: LocationWhereUniqueInput;
}

export interface LocationCreateInput {
  venueName?: String;
  continent: String;
  country: String;
  city: String;
  address: String;
  coordinates: CoordinatesCreateOneInput;
}

export interface CoordinatesCreateOneInput {
  create?: CoordinatesCreateInput;
  connect?: CoordinatesWhereUniqueInput;
}

export interface CoordinatesCreateInput {
  latitude: Float;
  longitude: Float;
}

export interface SocialCreateOneInput {
  create?: SocialCreateInput;
  connect?: SocialWhereUniqueInput;
}

export interface SocialCreateInput {
  facebook?: String;
  twitter?: String;
  instagram?: String;
}

export interface PriceCreateManyInput {
  create?: PriceCreateInput[] | PriceCreateInput;
  connect?: PriceWhereUniqueInput[] | PriceWhereUniqueInput;
}

export interface PriceCreateInput {
  name?: String;
  amount: Float;
  currency?: CURRENCY;
  expirationDate?: DateTimeInput;
}

export interface ConferenceUpdateInput {
  name?: String;
  description?: String;
  tags?: TagUpdateManyInput;
  url?: String;
  image?: ImageUpdateOneInput;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  location?: LocationUpdateOneRequiredInput;
  social?: SocialUpdateOneInput;
  publishStatus?: PUBLISH_STATUS;
  prices?: PriceUpdateManyInput;
}

export interface TagUpdateManyInput {
  create?: TagCreateInput[] | TagCreateInput;
  update?:
    | TagUpdateWithWhereUniqueNestedInput[]
    | TagUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TagUpsertWithWhereUniqueNestedInput[]
    | TagUpsertWithWhereUniqueNestedInput;
  delete?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  connect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  disconnect?: TagWhereUniqueInput[] | TagWhereUniqueInput;
  deleteMany?: TagScalarWhereInput[] | TagScalarWhereInput;
  updateMany?:
    | TagUpdateManyWithWhereNestedInput[]
    | TagUpdateManyWithWhereNestedInput;
}

export interface TagUpdateWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  data: TagUpdateDataInput;
}

export interface TagUpdateDataInput {
  name?: String;
  slug?: String;
}

export interface TagUpsertWithWhereUniqueNestedInput {
  where: TagWhereUniqueInput;
  update: TagUpdateDataInput;
  create: TagCreateInput;
}

export interface TagScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  slug?: String;
  slug_not?: String;
  slug_in?: String[] | String;
  slug_not_in?: String[] | String;
  slug_lt?: String;
  slug_lte?: String;
  slug_gt?: String;
  slug_gte?: String;
  slug_contains?: String;
  slug_not_contains?: String;
  slug_starts_with?: String;
  slug_not_starts_with?: String;
  slug_ends_with?: String;
  slug_not_ends_with?: String;
  AND?: TagScalarWhereInput[] | TagScalarWhereInput;
  OR?: TagScalarWhereInput[] | TagScalarWhereInput;
  NOT?: TagScalarWhereInput[] | TagScalarWhereInput;
}

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface TagUpdateManyDataInput {
  name?: String;
  slug?: String;
}

export interface ImageUpdateOneInput {
  create?: ImageCreateInput;
  update?: ImageUpdateDataInput;
  upsert?: ImageUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: ImageWhereUniqueInput;
}

export interface ImageUpdateDataInput {
  src?: String;
  alt?: String;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface LocationUpdateOneRequiredInput {
  create?: LocationCreateInput;
  update?: LocationUpdateDataInput;
  upsert?: LocationUpsertNestedInput;
  connect?: LocationWhereUniqueInput;
}

export interface LocationUpdateDataInput {
  venueName?: String;
  continent?: String;
  country?: String;
  city?: String;
  address?: String;
  coordinates?: CoordinatesUpdateOneRequiredInput;
}

export interface CoordinatesUpdateOneRequiredInput {
  create?: CoordinatesCreateInput;
  update?: CoordinatesUpdateDataInput;
  upsert?: CoordinatesUpsertNestedInput;
  connect?: CoordinatesWhereUniqueInput;
}

export interface CoordinatesUpdateDataInput {
  latitude?: Float;
  longitude?: Float;
}

export interface CoordinatesUpsertNestedInput {
  update: CoordinatesUpdateDataInput;
  create: CoordinatesCreateInput;
}

export interface LocationUpsertNestedInput {
  update: LocationUpdateDataInput;
  create: LocationCreateInput;
}

export interface SocialUpdateOneInput {
  create?: SocialCreateInput;
  update?: SocialUpdateDataInput;
  upsert?: SocialUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SocialWhereUniqueInput;
}

export interface SocialUpdateDataInput {
  facebook?: String;
  twitter?: String;
  instagram?: String;
}

export interface SocialUpsertNestedInput {
  update: SocialUpdateDataInput;
  create: SocialCreateInput;
}

export interface PriceUpdateManyInput {
  create?: PriceCreateInput[] | PriceCreateInput;
  update?:
    | PriceUpdateWithWhereUniqueNestedInput[]
    | PriceUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PriceUpsertWithWhereUniqueNestedInput[]
    | PriceUpsertWithWhereUniqueNestedInput;
  delete?: PriceWhereUniqueInput[] | PriceWhereUniqueInput;
  connect?: PriceWhereUniqueInput[] | PriceWhereUniqueInput;
  disconnect?: PriceWhereUniqueInput[] | PriceWhereUniqueInput;
  deleteMany?: PriceScalarWhereInput[] | PriceScalarWhereInput;
  updateMany?:
    | PriceUpdateManyWithWhereNestedInput[]
    | PriceUpdateManyWithWhereNestedInput;
}

export interface PriceUpdateWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput;
  data: PriceUpdateDataInput;
}

export interface PriceUpdateDataInput {
  name?: String;
  amount?: Float;
  currency?: CURRENCY;
  expirationDate?: DateTimeInput;
}

export interface PriceUpsertWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput;
  update: PriceUpdateDataInput;
  create: PriceCreateInput;
}

export interface PriceScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  currency?: CURRENCY;
  currency_not?: CURRENCY;
  currency_in?: CURRENCY[] | CURRENCY;
  currency_not_in?: CURRENCY[] | CURRENCY;
  expirationDate?: DateTimeInput;
  expirationDate_not?: DateTimeInput;
  expirationDate_in?: DateTimeInput[] | DateTimeInput;
  expirationDate_not_in?: DateTimeInput[] | DateTimeInput;
  expirationDate_lt?: DateTimeInput;
  expirationDate_lte?: DateTimeInput;
  expirationDate_gt?: DateTimeInput;
  expirationDate_gte?: DateTimeInput;
  AND?: PriceScalarWhereInput[] | PriceScalarWhereInput;
  OR?: PriceScalarWhereInput[] | PriceScalarWhereInput;
  NOT?: PriceScalarWhereInput[] | PriceScalarWhereInput;
}

export interface PriceUpdateManyWithWhereNestedInput {
  where: PriceScalarWhereInput;
  data: PriceUpdateManyDataInput;
}

export interface PriceUpdateManyDataInput {
  name?: String;
  amount?: Float;
  currency?: CURRENCY;
  expirationDate?: DateTimeInput;
}

export interface ConferenceUpdateManyMutationInput {
  name?: String;
  description?: String;
  url?: String;
  startDate?: DateTimeInput;
  endDate?: DateTimeInput;
  publishStatus?: PUBLISH_STATUS;
}

export interface CoordinatesUpdateInput {
  latitude?: Float;
  longitude?: Float;
}

export interface CoordinatesUpdateManyMutationInput {
  latitude?: Float;
  longitude?: Float;
}

export interface ImageUpdateInput {
  src?: String;
  alt?: String;
}

export interface ImageUpdateManyMutationInput {
  src?: String;
  alt?: String;
}

export interface LocationUpdateInput {
  venueName?: String;
  continent?: String;
  country?: String;
  city?: String;
  address?: String;
  coordinates?: CoordinatesUpdateOneRequiredInput;
}

export interface LocationUpdateManyMutationInput {
  venueName?: String;
  continent?: String;
  country?: String;
  city?: String;
  address?: String;
}

export interface PriceUpdateInput {
  name?: String;
  amount?: Float;
  currency?: CURRENCY;
  expirationDate?: DateTimeInput;
}

export interface PriceUpdateManyMutationInput {
  name?: String;
  amount?: Float;
  currency?: CURRENCY;
  expirationDate?: DateTimeInput;
}

export interface SocialUpdateInput {
  facebook?: String;
  twitter?: String;
  instagram?: String;
}

export interface SocialUpdateManyMutationInput {
  facebook?: String;
  twitter?: String;
  instagram?: String;
}

export interface TagUpdateInput {
  name?: String;
  slug?: String;
}

export interface TagUpdateManyMutationInput {
  name?: String;
  slug?: String;
}

export interface UserCreateInput {
  email: String;
  name: String;
  password: String;
  role?: USER_ROLE;
}

export interface UserUpdateInput {
  email?: String;
  name?: String;
  password?: String;
  role?: USER_ROLE;
}

export interface UserUpdateManyMutationInput {
  email?: String;
  name?: String;
  password?: String;
  role?: USER_ROLE;
}

export interface ConferenceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ConferenceWhereInput;
  AND?: ConferenceSubscriptionWhereInput[] | ConferenceSubscriptionWhereInput;
  OR?: ConferenceSubscriptionWhereInput[] | ConferenceSubscriptionWhereInput;
  NOT?: ConferenceSubscriptionWhereInput[] | ConferenceSubscriptionWhereInput;
}

export interface CoordinatesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CoordinatesWhereInput;
  AND?: CoordinatesSubscriptionWhereInput[] | CoordinatesSubscriptionWhereInput;
  OR?: CoordinatesSubscriptionWhereInput[] | CoordinatesSubscriptionWhereInput;
  NOT?: CoordinatesSubscriptionWhereInput[] | CoordinatesSubscriptionWhereInput;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ImageWhereInput;
  AND?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  OR?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
  NOT?: ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput;
}

export interface LocationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LocationWhereInput;
  AND?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  OR?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
  NOT?: LocationSubscriptionWhereInput[] | LocationSubscriptionWhereInput;
}

export interface PriceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PriceWhereInput;
  AND?: PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput;
  OR?: PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput;
  NOT?: PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput;
}

export interface SocialSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SocialWhereInput;
  AND?: SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput;
  OR?: SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput;
  NOT?: SocialSubscriptionWhereInput[] | SocialSubscriptionWhereInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TagWhereInput;
  AND?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  OR?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
  NOT?: TagSubscriptionWhereInput[] | TagSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Conference {
  id: ID_Output;
  name: String;
  description?: String;
  url: String;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  publishStatus?: PUBLISH_STATUS;
}

export interface ConferencePromise extends Promise<Conference>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  tags: <T = FragmentableArray<Tag>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  url: () => Promise<String>;
  image: <T = ImagePromise>() => T;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  location: <T = LocationPromise>() => T;
  social: <T = SocialPromise>() => T;
  publishStatus: () => Promise<PUBLISH_STATUS>;
  prices: <T = FragmentableArray<Price>>(
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface ConferenceSubscription
  extends Promise<AsyncIterator<Conference>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(
    args?: {
      where?: TagWhereInput;
      orderBy?: TagOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  url: () => Promise<AsyncIterator<String>>;
  image: <T = ImageSubscription>() => T;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  location: <T = LocationSubscription>() => T;
  social: <T = SocialSubscription>() => T;
  publishStatus: () => Promise<AsyncIterator<PUBLISH_STATUS>>;
  prices: <T = Promise<AsyncIterator<PriceSubscription>>>(
    args?: {
      where?: PriceWhereInput;
      orderBy?: PriceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Tag {
  id: ID_Output;
  name: String;
  slug: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
}

export interface Image {
  id: ID_Output;
  src: String;
  alt?: String;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  src: () => Promise<String>;
  alt: () => Promise<String>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  src: () => Promise<AsyncIterator<String>>;
  alt: () => Promise<AsyncIterator<String>>;
}

export interface Location {
  id: ID_Output;
  venueName?: String;
  continent: String;
  country: String;
  city: String;
  address: String;
}

export interface LocationPromise extends Promise<Location>, Fragmentable {
  id: () => Promise<ID_Output>;
  venueName: () => Promise<String>;
  continent: () => Promise<String>;
  country: () => Promise<String>;
  city: () => Promise<String>;
  address: () => Promise<String>;
  coordinates: <T = CoordinatesPromise>() => T;
}

export interface LocationSubscription
  extends Promise<AsyncIterator<Location>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  venueName: () => Promise<AsyncIterator<String>>;
  continent: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  coordinates: <T = CoordinatesSubscription>() => T;
}

export interface Coordinates {
  id: ID_Output;
  latitude: Float;
  longitude: Float;
}

export interface CoordinatesPromise extends Promise<Coordinates>, Fragmentable {
  id: () => Promise<ID_Output>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
}

export interface CoordinatesSubscription
  extends Promise<AsyncIterator<Coordinates>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
}

export interface Social {
  id: ID_Output;
  facebook?: String;
  twitter?: String;
  instagram?: String;
}

export interface SocialPromise extends Promise<Social>, Fragmentable {
  id: () => Promise<ID_Output>;
  facebook: () => Promise<String>;
  twitter: () => Promise<String>;
  instagram: () => Promise<String>;
}

export interface SocialSubscription
  extends Promise<AsyncIterator<Social>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  facebook: () => Promise<AsyncIterator<String>>;
  twitter: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
}

export interface Price {
  id: ID_Output;
  name?: String;
  amount: Float;
  currency?: CURRENCY;
  expirationDate?: DateTimeOutput;
}

export interface PricePromise extends Promise<Price>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  amount: () => Promise<Float>;
  currency: () => Promise<CURRENCY>;
  expirationDate: () => Promise<DateTimeOutput>;
}

export interface PriceSubscription
  extends Promise<AsyncIterator<Price>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Float>>;
  currency: () => Promise<AsyncIterator<CURRENCY>>;
  expirationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ConferenceConnection {}

export interface ConferenceConnectionPromise
  extends Promise<ConferenceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ConferenceEdge>>() => T;
  aggregate: <T = AggregateConferencePromise>() => T;
}

export interface ConferenceConnectionSubscription
  extends Promise<AsyncIterator<ConferenceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ConferenceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateConferenceSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ConferenceEdge {
  cursor: String;
}

export interface ConferenceEdgePromise
  extends Promise<ConferenceEdge>,
    Fragmentable {
  node: <T = ConferencePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ConferenceEdgeSubscription
  extends Promise<AsyncIterator<ConferenceEdge>>,
    Fragmentable {
  node: <T = ConferenceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateConference {
  count: Int;
}

export interface AggregateConferencePromise
  extends Promise<AggregateConference>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateConferenceSubscription
  extends Promise<AsyncIterator<AggregateConference>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CoordinatesConnection {}

export interface CoordinatesConnectionPromise
  extends Promise<CoordinatesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CoordinatesEdge>>() => T;
  aggregate: <T = AggregateCoordinatesPromise>() => T;
}

export interface CoordinatesConnectionSubscription
  extends Promise<AsyncIterator<CoordinatesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CoordinatesEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCoordinatesSubscription>() => T;
}

export interface CoordinatesEdge {
  cursor: String;
}

export interface CoordinatesEdgePromise
  extends Promise<CoordinatesEdge>,
    Fragmentable {
  node: <T = CoordinatesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CoordinatesEdgeSubscription
  extends Promise<AsyncIterator<CoordinatesEdge>>,
    Fragmentable {
  node: <T = CoordinatesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCoordinates {
  count: Int;
}

export interface AggregateCoordinatesPromise
  extends Promise<AggregateCoordinates>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCoordinatesSubscription
  extends Promise<AsyncIterator<AggregateCoordinates>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageConnection {}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface ImageEdge {
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LocationConnection {}

export interface LocationConnectionPromise
  extends Promise<LocationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LocationEdge>>() => T;
  aggregate: <T = AggregateLocationPromise>() => T;
}

export interface LocationConnectionSubscription
  extends Promise<AsyncIterator<LocationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LocationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLocationSubscription>() => T;
}

export interface LocationEdge {
  cursor: String;
}

export interface LocationEdgePromise
  extends Promise<LocationEdge>,
    Fragmentable {
  node: <T = LocationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LocationEdgeSubscription
  extends Promise<AsyncIterator<LocationEdge>>,
    Fragmentable {
  node: <T = LocationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLocation {
  count: Int;
}

export interface AggregateLocationPromise
  extends Promise<AggregateLocation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLocationSubscription
  extends Promise<AsyncIterator<AggregateLocation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PriceConnection {}

export interface PriceConnectionPromise
  extends Promise<PriceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PriceEdge>>() => T;
  aggregate: <T = AggregatePricePromise>() => T;
}

export interface PriceConnectionSubscription
  extends Promise<AsyncIterator<PriceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PriceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePriceSubscription>() => T;
}

export interface PriceEdge {
  cursor: String;
}

export interface PriceEdgePromise extends Promise<PriceEdge>, Fragmentable {
  node: <T = PricePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PriceEdgeSubscription
  extends Promise<AsyncIterator<PriceEdge>>,
    Fragmentable {
  node: <T = PriceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePrice {
  count: Int;
}

export interface AggregatePricePromise
  extends Promise<AggregatePrice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePriceSubscription
  extends Promise<AsyncIterator<AggregatePrice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SocialConnection {}

export interface SocialConnectionPromise
  extends Promise<SocialConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SocialEdge>>() => T;
  aggregate: <T = AggregateSocialPromise>() => T;
}

export interface SocialConnectionSubscription
  extends Promise<AsyncIterator<SocialConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SocialEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSocialSubscription>() => T;
}

export interface SocialEdge {
  cursor: String;
}

export interface SocialEdgePromise extends Promise<SocialEdge>, Fragmentable {
  node: <T = SocialPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SocialEdgeSubscription
  extends Promise<AsyncIterator<SocialEdge>>,
    Fragmentable {
  node: <T = SocialSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSocial {
  count: Int;
}

export interface AggregateSocialPromise
  extends Promise<AggregateSocial>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSocialSubscription
  extends Promise<AsyncIterator<AggregateSocial>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagConnection {}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface TagEdge {
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  email: String;
  name: String;
  createdAt: DateTimeOutput;
  password: String;
  role: USER_ROLE;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  password: () => Promise<String>;
  role: () => Promise<USER_ROLE>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<USER_ROLE>>;
}

export interface UserConnection {}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ConferenceSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ConferenceSubscriptionPayloadPromise
  extends Promise<ConferenceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ConferencePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ConferencePreviousValuesPromise>() => T;
}

export interface ConferenceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ConferenceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ConferenceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ConferencePreviousValuesSubscription>() => T;
}

export interface ConferencePreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  url: String;
  startDate: DateTimeOutput;
  endDate: DateTimeOutput;
  publishStatus?: PUBLISH_STATUS;
}

export interface ConferencePreviousValuesPromise
  extends Promise<ConferencePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  url: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  publishStatus: () => Promise<PUBLISH_STATUS>;
}

export interface ConferencePreviousValuesSubscription
  extends Promise<AsyncIterator<ConferencePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishStatus: () => Promise<AsyncIterator<PUBLISH_STATUS>>;
}

export interface CoordinatesSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CoordinatesSubscriptionPayloadPromise
  extends Promise<CoordinatesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CoordinatesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CoordinatesPreviousValuesPromise>() => T;
}

export interface CoordinatesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CoordinatesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CoordinatesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CoordinatesPreviousValuesSubscription>() => T;
}

export interface CoordinatesPreviousValues {
  id: ID_Output;
  latitude: Float;
  longitude: Float;
}

export interface CoordinatesPreviousValuesPromise
  extends Promise<CoordinatesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  latitude: () => Promise<Float>;
  longitude: () => Promise<Float>;
}

export interface CoordinatesPreviousValuesSubscription
  extends Promise<AsyncIterator<CoordinatesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  latitude: () => Promise<AsyncIterator<Float>>;
  longitude: () => Promise<AsyncIterator<Float>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface ImagePreviousValues {
  id: ID_Output;
  src: String;
  alt?: String;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  src: () => Promise<String>;
  alt: () => Promise<String>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  src: () => Promise<AsyncIterator<String>>;
  alt: () => Promise<AsyncIterator<String>>;
}

export interface LocationSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LocationSubscriptionPayloadPromise
  extends Promise<LocationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LocationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LocationPreviousValuesPromise>() => T;
}

export interface LocationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LocationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LocationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LocationPreviousValuesSubscription>() => T;
}

export interface LocationPreviousValues {
  id: ID_Output;
  venueName?: String;
  continent: String;
  country: String;
  city: String;
  address: String;
}

export interface LocationPreviousValuesPromise
  extends Promise<LocationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  venueName: () => Promise<String>;
  continent: () => Promise<String>;
  country: () => Promise<String>;
  city: () => Promise<String>;
  address: () => Promise<String>;
}

export interface LocationPreviousValuesSubscription
  extends Promise<AsyncIterator<LocationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  venueName: () => Promise<AsyncIterator<String>>;
  continent: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
}

export interface PriceSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PriceSubscriptionPayloadPromise
  extends Promise<PriceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PricePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PricePreviousValuesPromise>() => T;
}

export interface PriceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PriceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PriceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PricePreviousValuesSubscription>() => T;
}

export interface PricePreviousValues {
  id: ID_Output;
  name?: String;
  amount: Float;
  currency?: CURRENCY;
  expirationDate?: DateTimeOutput;
}

export interface PricePreviousValuesPromise
  extends Promise<PricePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  amount: () => Promise<Float>;
  currency: () => Promise<CURRENCY>;
  expirationDate: () => Promise<DateTimeOutput>;
}

export interface PricePreviousValuesSubscription
  extends Promise<AsyncIterator<PricePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Float>>;
  currency: () => Promise<AsyncIterator<CURRENCY>>;
  expirationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface SocialSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SocialSubscriptionPayloadPromise
  extends Promise<SocialSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SocialPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SocialPreviousValuesPromise>() => T;
}

export interface SocialSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SocialSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SocialSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SocialPreviousValuesSubscription>() => T;
}

export interface SocialPreviousValues {
  id: ID_Output;
  facebook?: String;
  twitter?: String;
  instagram?: String;
}

export interface SocialPreviousValuesPromise
  extends Promise<SocialPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  facebook: () => Promise<String>;
  twitter: () => Promise<String>;
  instagram: () => Promise<String>;
}

export interface SocialPreviousValuesSubscription
  extends Promise<AsyncIterator<SocialPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  facebook: () => Promise<AsyncIterator<String>>;
  twitter: () => Promise<AsyncIterator<String>>;
  instagram: () => Promise<AsyncIterator<String>>;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  name: String;
  slug: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  slug: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  slug: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  name: String;
  createdAt: DateTimeOutput;
  password: String;
  role: USER_ROLE;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  password: () => Promise<String>;
  role: () => Promise<USER_ROLE>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<USER_ROLE>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models = [
  {
    name: "CURRENCY",
    embedded: false
  },
  {
    name: "Conference",
    embedded: false
  },
  {
    name: "Coordinates",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  },
  {
    name: "Location",
    embedded: false
  },
  {
    name: "PUBLISH_STATUS",
    embedded: false
  },
  {
    name: "Price",
    embedded: false
  },
  {
    name: "Social",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  },
  {
    name: "USER_ROLE",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}`,
  secret: `${process.env["PRISMA_SECRET"]}`
});
export const prisma = new Prisma();
